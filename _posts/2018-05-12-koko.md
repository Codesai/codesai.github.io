---
layout: post
title: "Improving legacy Om code by isolating effectful code using effects and coeffects"
date: 2018-05-12 18:30:00.000000000 +01:00
type: post
published: true
status: publish
categories:
  - Clojure/ClojureScript
  - Testing

author: Manuel Rivero
small_image: small_pineapples.jpeg
written_in: english
cross_post_url: http://garajeando.blogspot.com.es/2018/04/test-doubles-small-spying-and-stubbing.html
---

I'm working at [GreenPowerMonitor](http://www.greenpowermonitor.com/) as part of a team developing a challenging SPA to monitor and manage renewable energy portfolios using ClojureScript. It's a two years old Om application which contains a lot of legacy code. When I say legacy, I'm using [Michael Feathers](https://michaelfeathers.silvrback.com/)' definition of legacy code as **_code without tests_**. This definition views legacy code from the perspective of **_code being difficult to evolve because of a lack of automated regression tests_**.  

### The legacy (untested) Om code
Recently I had to face one of these legacy parts when I had to fix some bugs in the user interface that was presenting all the devices of a given energy facility in a hierarchy tree (devices might be comprised of other devices). This is the original legacy (untested) Om code in `horizon.controls.widgets.tree.hierarchy`:  
<script src="https://gist.github.com/trikitrok/a47fefc77175f5151031380ebc3f4fb5.js"></script>
(see gist in https://gist.github.com/trikitrok/a47fefc77175f5151031380ebc3f4fb5) 

This code contains not only the layout of several components but also the logic both to conditionally render some parts of them and to respond to user interactions. The interesting logic is full of asynchronous and effectful code that is reading and updating the state of the components, extracting information from the DOM and reading and updating the global application state. All this makes this code very hard to test.  

### Humble Object pattern
It's very difficult to make [component tests](https://garajeando.blogspot.com.es/2017/06/testing-om-components-with-cljs-react.html) for non-component code like the one in this namespace, which makes writing end-to-end tests look like the only option.  

However, following the idea of the [humble object pattern](http://xunitpatterns.com/Humble%20Object.html), we might reduce the untested code to just the layout of the view. The [humble object](http://xunitpatterns.com/Humble%20Object.html) can be used when a code is too closely coupled to its environment to make it testable . To apply it, the interesting logic is extracted into a separate easy-to-test component that is decoupled from its environment.  

In this case we extracted the interesting logic to a separate namespace, `horizon.controls.widgets.tree.hierarchy-helpers`, and we thoroughly tested it. With this we avoided writing the slower and more fragile end-to-end tests.  

We wrote the tests using the [test-doubles](https://github.com/GreenPowerMonitor/test-doubles) library (I've talked about it in [a recent post](http://garajeando.blogspot.com.es/2018/04/test-doubles-small-spying-and-stubbing.html)) and some home-made tools that help testing asynchronous code based on [core.async](https://github.com/clojure/core.async).  

This is the logic we extracted to `horizon.controls.widgets.tree.hierarchy-helpers`:  
<script src="https://gist.github.com/trikitrok/46253df8ad51894fcd78b5edca0b5540.js"></script>
(see gist in https://gist.github.com/trikitrok/46253df8ad51894fcd78b5edca0b5540) 

and these are the tests we wrote for it:  
<script src="https://gist.github.com/trikitrok/cfa89cbaddfe44bc5f816b85b4981284.js"></script>
(see gist in https://gist.github.com/trikitrok/cfa89cbaddfe44bc5f816b85b4981284) 

See [here](https://gist.github.com/trikitrok/a6647dd274e5df3bae2e46ac38a53c50) how `horizon.controls.widgets.tree.hierarchy` looks after this extraction. Using the [humble object pattern](http://xunitpatterns.com/Humble%20Object.html), we managed to test the most important bits of logic with fast unit tests instead of end-to-end tests.  

### The real problem was bad design
We could have left this code as it was (in fact we did for a while), but, if you look at these tests, you'll see that they are very brittle tests because they are highly coupled to implementation details.  

We also had to use heavy tooling, the (_with-doubles_ library and our _async-test-tools_) to be able to test this code. The real problem that was making the code hard to test was that its design was far from ideal because there was a lack of separation of concerns. It was that design which was forcing us to mock so heavily and to face asynchronous code testing.  
The problem was that, even though extracting the important logic allowed us to focus on the tests that added more value for us, the extracted logic was hard to test and hard to reason about because its effectful parts were not isolated from the pure ones. The extracted code was mutating and reading state, getting data from globals and getting data from the DOM nearly everywhere, and that destroyed any advantage functional programming might offer, such as being really easy to test and reason about.  

### Refactoring to isolate side-effects and side-causes using effects and coeffects

We refactored the code to isolate side-effects and side-causes from pure logic. This way, not only testing the logic got much easier (the logic would be in pure functions), but also, it made tests less coupled to implementation details. To achieve this we introduced the concepts of coeffects and effects.  

The basic idea of the new design was:

1.  Extracting all the needed data from globals (using coeffects for getting application state, getting component state, getting DOM state, etc).
2.  Using pure functions to compute the description of the side effects to be performed (returning effects for updating application state, sending messages, etc) given what was extracted in the previous step (the coeffects).
3.  Performing the side effects described by the effects returned by the called pure functions.

The main difference that the code of `horizon.controls.widgets.tree.hierarchy` presented after this refactoring was that the event handler functions were moved back into it again, and that they were using the _process-all!_ and _extract-all!_ functions that were used to perform the side-effects described by effects, and extract the values of the side-causes tracked by coeffects, respectively. The event handler functions are shown in the next snippet (to see the whole code click [here](https://gist.github.com/trikitrok/03ed9b48d3e9f4942a60a5810347793e)): <script src="https://gist.github.com/trikitrok/ffa05e2a36799d609d8dea84f8b3da46.js"></script>
(see gist in https://gist.github.com/trikitrok/ffa05e2a36799d609d8dea84f8b3da46) 

Now all the logic in the companion namespace was comprised of pure functions, with neither asynchronous nor mutating code:  
<script src="https://gist.github.com/trikitrok/f7c5ed3b36bb9fc4eaa07321e078fa78.js"></script>
(see gist in https://gist.github.com/trikitrok/f7c5ed3b36bb9fc4eaa07321e078fa78) 

Thus, its tests became much simpler:  
<script src="https://gist.github.com/trikitrok/0dac9219c32d5cbb60a6b77ca1e7bb0f.js"></script>
(see gist in https://gist.github.com/trikitrok/0dac9219c32d5cbb60a6b77ca1e7bb0f) 

Notice how the pure functions receive a map of coeffects already containing all the extracted values they need from the "world" and they return a map with descriptions of the effects. This makes testing really much easier than before, and remove the need to use test doubles.  

Notice also how the test code is now around 100 lines shorter. The main reason for this is that the new tests know much less about how the production code is implemented than the previous one. This made possible to remove some tests that, in the previous version of the code, were testing some branches that we were considering reachable when testing implementation details, but when considering the whole behaviour are actually unreachable.  

Now let's see the code that is extracting the values tracked by the coeffects:  
<script src="https://gist.github.com/trikitrok/01273163c6e93aa4496cf2c0a9ebe556.js"></script>
(see gist in https://gist.github.com/trikitrok/01273163c6e93aa4496cf2c0a9ebe556) 

which is using several implementations of the _Coeffect_ protocol:  
<script src="https://gist.github.com/trikitrok/d240b2308e76b8127204956f29cb2ac6.js"></script>
(see gist in https://gist.github.com/trikitrok/d240b2308e76b8127204956f29cb2ac6) 

All the coeffects were created using factories to localize in only one place the "shape" of each type of coeffect. This indirection proved very useful when we decided to refactor the code that extracts the value of each coeffect to substitute its initial implementation as a conditional to its current implementation using polymorphism with a protocol. 

These are the coeffects factories:  
<script src="https://gist.github.com/trikitrok/3456c8c43f6d734ddf7a68e6b8be3e96.js"></script>
(see gist in https://gist.github.com/trikitrok/3456c8c43f6d734ddf7a68e6b8be3e96) 

Now there was only one place where we needed to test side causes (using test doubles for some of them). These are the tests for extracting the coeffects values:  
<script src="https://gist.github.com/trikitrok/3b3714472c1766d3b291eb9f782c1846.js"></script>
(see gist in https://gist.github.com/trikitrok/3b3714472c1766d3b291eb9f782c1846) 

A very similar code is processing the side-effects described by effects:  
<script src="https://gist.github.com/trikitrok/aad28ce4569bc4005dfb1e9f36282824.js"></script>
(see gist in https://gist.github.com/trikitrok/aad28ce4569bc4005dfb1e9f36282824) 

which uses different effects implementing the _Effect_ protocol:  
<script src="https://gist.github.com/trikitrok/aecfedb1900969558299eecb3ad463dc.js"></script>
(see gist in https://gist.github.com/trikitrok/aecfedb1900969558299eecb3ad463dc) 

that are created with the following factories:  
<script src="https://gist.github.com/trikitrok/32e1c587af848dc7c4caffe24ccfb77e.js"></script>
(see gist in https://gist.github.com/trikitrok/32e1c587af848dc7c4caffe24ccfb77e) 

Finally, these are the tests for processing the effects:  
<script src="https://gist.github.com/trikitrok/a552c25c69d2be1ef032574e1a87ac50.js"></script>
(see gist in https://gist.github.com/trikitrok/a552c25c69d2be1ef032574e1a87ac50)

### Summary

We have seen how by using the concept of effects and coeffects, we were able to refactor our code to get a new design that isolates the effectful code from the pure code. This made testing our most interesting logic really easy because it became comprised of only pure functions.  

The basic idea of the new design was:

1.  Extracting all the needed data from globals (using coeffects for getting application state, getting component state, getting DOM state, etc).
2.  Computing in pure functions the description of the side effects to be performed (returning effects for updating application state, sending messages, etc) given what it was extracted in the previous step (the coeffects).
3.  Performing the side effects described by the effects returned by the called pure functions.

Since the time we did this refactoring, we have decided to go deeper in this way of designing code and we’re implementing a full effects & coeffects system inspired by [re-frame](https://github.com/Day8/re-frame).